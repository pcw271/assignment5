1. Line 37 in adventure.py, I changed the raw_input() to input().2. 
(1) Applied modular programming to split different functions into separate modules: the adventure.py was designed to run the game and game.py to track the state of the game (2) Common used functions/classes were built in model.py to make these codes reusable in multiple places(3) In the test_data.py, each assertion was built separately as a definition 3. 
Meaningful names: line 130 -143 in the model.py, functions like carry, drop, hide, destroy were meaningful names; classes defined in the model.py (message, move..) were also meaningful. No meaningful names: line 130 in the game.py, start2 function was not meaningful to me. Also, as comment indicated (line 57 in data.py), sections defined in the data.py required knowledge to understand the meaning, which were not clear. 4. line 57 – 67 in game.py, define random, choice, write.. they all only did one thing in the definition. Line 772 in the game.py, die function not only recorded depth, but also defined another function inside the “die” function for callback.    5. Line 822 in game.py, write_default_message not only wrote the message, but would also finish_turn(), which was not the intention of this function. 6. In play.py, 
“global _gamefrom game import Gamefrom prompt import install_words” were repeated twice in the same python code. 7. Yes, line 1554 in game.py, the code used  try  to handle some exception. Also, in the adventure.py, it used try/except function to handle error. When I tried to use ~,#,@ or special symbols, it seemed that the python did not have any response (even though it didn’t break the code) 8. Class Game(Data) in the game.py handled tons of functionality for the game. Class Object(object) in the model.py also handled the multiple functions like hide, drop, is_at, and destroy 9. Class Game(Data) again was not cohesive as well with 15 attributes. Class Move(object), Class Room(object), Hint(object) and so on also were not cohesive.  10. 
Good comments: Author defined a class with “”” “””, which can be easily displayed as an explanation in the iPython. Comments for attributes were placed on the same line (such as line 21 in game.py), which made the comments easy to read. Bad comments: line 380 -383 in the game.py, it seemed that author commented out something that was not relevant to the code.  11. I think line 427-499 in the game.py is a good example of the vertical formatting. Not only it separated code blocks by a blank line, but also put two related functions (do_command, _do_command) appeared close with each other. 
12. 
In order to run test_command.py and test_data.py, I added import sys and insert sys.path.insert() so that the test python can refer to the package in the parent folder (code ref: http://askubuntu.com/questions/470982/how-to-add-a-python-module-to-syspath). 

I could run the test_command.py and test_data.py, but not test_walk.py. The code could pass in the 2 tests I were able to run. 

Regardless, I think the test is for sure self-validating since the test return pass or fail. And the test code also ran fast on the machine. The test code was also independent since all the functions were asserted independently and did not seem to relay on each other. 