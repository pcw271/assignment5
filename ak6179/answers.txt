1. To make the code work for Python3 I changed the code in line-37: "line = raw_input('> ')" to
"line = line = input('> ')" in "adventure/adventure.py" file. I made this change because "raw_input" method from
Python2 has been changed to "input" method in Python3.

I also added the "walkthrough1.txt" and "walkthrough2.txt" test to test the code more thoroughly. These tests are
present at line-9 and line-10 in "adventure/tests/test_walks.py" file. To make the "walkthrough1.txt" and
"walkthrough2.txt" tests run correctly I had to replace "adventure.resume(savefile)"
(file "adventure/tests/walkthrough1.txt", line-863) with "play.resume(savefile)". I also had to replace
"adventure._game.clock1" (file "adventure/tests/walkthrough2.txt", line-1172) with "play._game.clock1".
I had to make these changes because the "resume" and the "_game.clock1" are members of "play" and not "adventure".

I am not sure if we were required to pass "walkthrough1.txt" and "walkthrough2.txt" tests but I ran those tests
just for completion.

2.
a) The author has used modular programming for organizing the different parts. Eg: For abstracting the user
interacting with the game the author has created a "play" file which contains methods through which the player
interacts with the game. For defining the game the author has used a "game" class which contains the structure
(model class), feature and characteristics of the game.
For starting a game the author has used methods in the "adventure.py" file.

b)The author has also created classes to define the different objects.
Using these files he is able to better model an interaction in between the objects.
Eg: The author has created a separate "data" class which deals with the "advent.dat" file. The data is used
to define the moves and different positions in the game. The author has also created a "Move" class (in model.py)
which is used to model an entry in the travel table.

c) The author has also abstracted out the interactions between the different components of the game. For doing this
he/she has used functions like "resume" (in play.py) which is used to load an existing game from a file
and start from the saved position. There are methods to check characteristics of different parts of the game
like "is_dark()" is used to check if a room is dark. The author has also added unit-tests for the game to check
for correctness.

3. Examples of meaningful names:
    - "is_dark" (in model.py line-79) function which is used to check if a room is dark.
    - The class "Room" (in model.py line-38) which is used to model room in the game.
    - The "resume" function (in play.py line-29) which is used to load a previously saved game.

   Examples where author has not used meaningful names:
   - "start2" (in game.py line-130)
   - "i_carry" (in game.py line-834)
   - "dictionary" (in data.py line-44): it would have been helpful if the author indicated the type of
   elements present in the dictionary.

4. Examples of functions doing only one thing:
    - "write_message" (in game.py line-69): this function just writes messages to the screen.
    - "random" (in game.py line-57): return a random number between 0 and 1.
    - "die_here" (in game.py line-767)

   Examples of functions doing multiple things:
   - "do_command" (in game.py line-429): it parses the command and also acts upon the command
   - "move_dwarves" (in game.py line-188): it loopes through the dwarves and also moves each individual dwarf.
   Moving of each single dwarf should have been done by a different function.
   - "finish_turn" (in game.py line-384): it does multiple tasks like checking if hint should be given, randomly
   setting the state of the game etc.

5. I think the function "finish_turn" (in game.py line-384) has a side-effect because it performs more than 1 task and
the name of function "finish_turn" does not imply that it should be performing these tasks. The function offers
hints and it also advances the random number generator. These tasks are not supposed to be performed by the
"finish_turn" function.

6. One example of repeatable code is in the file game.py (line-847-855):
    if obj.is_fixed or len(obj.rooms) > 1:
        if obj is self.plant and obj.prop <= 0:
            self.write_message(115)
        elif obj is self.bear and obj.prop == 1:
            self.write_message(169)
        elif obj is self.chain and self.chain.prop != 0:
            self.write_message(170)
        else:
            self.write_message(25)


    This code can be simplified by writing a method to get the value for write_message and then just
    using one command for write_message. Eg:
    v = get_val(obj)
    self.write_message(v)

7. The program handles the EOFError exception in the adventure.py file (line-45). One input for
which the program doesn't behave as expected is if you enter non-ASCII characters like: ☀, ☂. The program
doesn't crash but it doesn't prompt the player to enter a valid sentence.

8. The class Game (game.py line-19) is responsible for more than one piece of functionality. It is responsible for
handling the different parts of the game and is also responsible for communicating the messages from the game
to the player. It would have been better to abstract out the communication part to a different class.

9. In my opinion some of the classes are cohesive and some aren't. Eg: The "Game "class (game.py line-19)
 is in good cohesion with different objects of the game like Pirate, Room etc. A class which is not in good
 cohesion is the "Object" class (model.py line-103). This class represents the objects in the game and is also used
 for interaction with these objects like lifting them, moving them which in my opinion is asynchronous.

10. The author uses comment to talk about some of the important parts of the game. Comments are also used when
the name of the object, function is not descriptive. Example of useful comment: "parse" function (data.py line-198).
Through the comment """Read the Adventure data file and return a ``Data`` object.""" the author tells the abstract
object on which the parse function acts. Another example of a useful comment is in the description of
"Object" class (model.py line-103). The comment is
"""An object in the game, like a grate, or a rod with a rusty star.""". This comment in particular gives us a better
idea about the object.

In the code there are many not so useful comments also like the comment """Start the game.""" inside the "start"
function (file game.py line-114). The intent of the comment is already communicated by the name of the function.
Another useless comment is """A location in the game.""" present at line-38 of model.py inside the "Room" class.
In this case also the intent of the comment is already communicated by the name of the class.

11. An example of vertical formatting: (file game.py line-165)
           must_allow_move = ((newloc is loc) or (loc.is_forced)
                           or (loc.is_forbidden_to_pirate))

12. All the tests pass. There were a few commented out tests also. I had to make some modifications to pass them.
I have described the modifications in answer to part 1. I will analyze the F.I.R.S.T principle conformity below:

Fast: The tests run fast enough so that they can be tested frequently.

Independent: The tests are independent and can be run in any order.

Repeatable: The tests are repeatable in any environment unless you are running on a really obscure configuration.

Self-Validating: The tests are self-validating because they use assert statements to check the correctness
at different positions.

Timely: I don't think that the tests were written during code-development because they only check a high-level
behavior of the program and don't evalute things at a lower level.

So in my opinion the tests conform to F, I, R, S principles but don't conform to the T principle.


